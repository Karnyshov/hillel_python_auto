# coding: utf-8

s1 = "john marta james Morgan Adam Maria huang"
s2 = "name=Amanda=sssss&age=32&salary=1500&currency=quro"
l2 = ["FirstItem", "FriendsList", "MyTuple"]
s3 = """Есть строка с именами разделенная пробелами "john marta james Morgan Adam Maria huang". Преобразовать строку таким образом, что бы каждое имя однозначно начиналось с большой буквы. Есть список друзей ["John", "Marta", "James", "Amanda", "Marianna"]. Выведите в консоль имена каждое с новой строки выровняв по правой стороне используя метод строки и форматирование через f string. Так же над именами первой строкой выведен заговловок Names, где слово names должно быть посредине, а остальное пространство заполнено скажем символом "*". Есть строка переданная в качестве квери параметров "name=Amanda=sssss&age=32&&salary=1500&currency=quro ". Преобразовать эту строку в словарь где ключем должно быть значение перед = а значение пары значение после равно {name: Amanda=sssss, age: 32, salary: 1500, currency: quro}. У вас есть список имен переменных в формате кэмел кейс ["FirstItem", "FriendsList", "MyTuple"]. Преобразовать его в список имен переменных для пайтона в формате снейк кейс ["first_item", "friends_list", "my_tuple"]. У вас есть текст, разбейте текст по предложениям. В качестве результата вы должны получить список из предложений. Текст - все чтот выше.
"""


def task_1(str1):
    return str1.title()


"""
Задача №2. Механизм более сложный, чем задумывалось (наверное), но по другому я не вижу как сделать, да и будет 
дублирование строк.
"""


def task_2():
    l1 = ["John", "Marta", "James", "Amanda", "Marianna"]
    length = len(l1[0])

    for x in l1:
        if len(x) > length:
            length = len(x)

    print("Names".center(length * 2, "*"))

    for x in l1:
        print(f"{x}".rjust(length+2, "-"))


"""
Задача №3. Механизм более сложный, чем задумывалось, но по другому я не вижу как сделать, да и будет 
дублирование строк. Но тем не менее понимаю, что можно проще и интересно посмотреть на более оптимальное решение.
"""


def task_3(str2):
    copy = str2
    result = {}
    while True:
        sep_1 = copy.find("=")
        keyw = copy[0:sep_1]

        sep_2 = copy.find("&")
        val = copy[sep_1 + 1:sep_2]

        result[keyw] = f"{val}"
        copy = copy[sep_2+1::]

        if copy.count("&") == 0:
            result[copy[0:copy.find("=")]] = copy[copy.find("=") + 1::]
            break

    return result


"""
Задача №4. Признаюсь честно, пытался в лоб решить, но понял, что оно совсем криво получается и будет стыдно.
Вспомнил про .join(), попробовал на одном слове и загуглил в правильном ли направлении иду. Был, конечно, еще вариант
с регуляркой, но посчитал, что это через чур.
"""


def task_4(lst2):
    result = []
    for x in lst2:
        result.append("".join(["_" + y.lower() if y.isupper() else y for y in x]).replace("_", "", 1))

    return result



"""
Тут возникли проблемы с кодировкой, пытался в настройках IDE сделать - не вышло, загуглил и добавил строчку с кодировкой
в начале файла. Возможно, из-за этого (или из-за символов новой строки), у предложений в начале есть пробел. Пробовал
убрать через .lstrip(), .replace() - не вышло. Буду признателен, если подскажете более оптимальный вариант (если такой
есть).
"""


def task_5(str3):
    return str3.split(".")


print(task_1(s1))

print(task_2())

print(task_3(s2))

print(task_4(l2))

print(task_5(s3))
